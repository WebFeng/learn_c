#include <stdio.h>

int main()
{
/*指针与地址*/
//指针为存储地址的变量,定义时必须指明指针指向对象的类型,void类型的指针可以存放任何类型的指针,但不能通过*间接引用其自身.
//举例
    int x = 1, y = 2, z[10];
    int *ip; //ip指向int类型的指针
    ip = &x; //ip指向x
    y = *ip; //y的值为1
    *ip = 0; //x的值为0
    ip = &z[0]; //ip指向z[0]
    *z[0] = 2; //z[0]的值为2
//取址&和间接引用*优先级比算术运算符高, 和++ --优先级相同, 结合行从右至左
    ++*ip;(*ip)++;//作用相同

/*指针与函数参数*/
//用指针可以在被调函数中改变主调函数的变量值

/*指针与数组*/
//指针变量与数组变量唯一不同之处在于指针变量是变量, 可以自增来改变自己, 例如
    int *p; p++; //指针可以自增
    int v[10] = {1,2}; //此时不可执行v++, 因为v不是变量,是数组首元素地址;
//数组名代表数组首元素地址
//数组退化为指针后,长度信息会丢失,所以在设计时,应该是deal_array(int *v, arr_len);
    int a[10];
    int *pa;
    pa = &a[0];/*等同于*/pa = a;
    pa + 1;//指向下一个元素
    pa - 1;//指向上一个元素
    *(pa+i);/*等同于*/a[i];
    &a[i];/*等同于*/a+i;
//以下strlen的使用都是合法的
    int strlen(char *s);
    strlen("hello, world"); //字符串常量
    strlen(array); //字符数组
    strlen(ptr); //ptr是一个指向char类型对象的指针
//在函数中,以下是等价的
    char s[];/*等价*/char *s;
//也可以将数组的一部分传递给函数
    f(&a[2]);
    f(a + 2);
//如果确信元素存在,则以下访问也是合法的.
    p[-1];//访问p之前的一个元素
    p[-2];//访问p之前的两个元素

/*地址算数运算*/
//库函数存储分配与释放
    malloc();
    free();
//指针与整数不能相互转换,0例外,0可以赋值给指针,指针也可以和0比较,常用NULL替代0,NULL定义在<stddef.h>
//如果两个指针指向同一个数组,则两个指针可以进行关系比较运算 == != < >=
//指针p+n代表p指向当前对象后n个对象的地址,计算方式为 当前对象地址+指针指向的对象占据的存储空间*n

/*字符指针与函数*/
//字符数组也有\0作为结束标志
    char s1[] = {'a', 'b', 'c'};/*等价于*/char s2[] = {'a', 'b', 'c', '\0'};
    char s3[3] = {'a', 'b', 'c'};//这种写法是错误的,会导致\0没有地方存储
//c没有提供整个字符串复制的运算符
    char *p;
    *p = "abc";//这种操作是错误的
//数组在初始化时长度就固定了,所以扩增数组的长度是错误的
    char v[] = "abc";//初始化了数组长度为4,最后一位为'\0';
    v[3] = 'd';//这种操作是错误的
//标准进栈出栈的用法, * ++ -- 优先级相同,结合性从右到左,
    *p++ = value; //将value压入栈.从右到左先执行p++,在把p未加的地址给*,赋值value,再把指针后移一位
    value = *--p; //将栈顶元素弹出到value.从右到左,先把指针左移一位,再把值给value.
//Bus Error 是由于未对齐导致的,比如strcpy(char *s, char *t), 把t拷贝到s
    char *s, *t = "abc";//错误
    char s[4], *t = "abc";//正确
    strcpy(s, t)

/*指针数组以及指向指针的指针*/
    char *lineptr[10];//这是一个指针数组,包含10个元素的数组,每个元素都是指向char类型的指针

/*多维数组*/
//多维数组类似矩阵,但使用并没有指针数组广泛
//判断闰年
    int leap, year;
    leap = year%4 == 0 && year%100 !=0 || year%400 == 0;
//指针必须初始化才能使用,未初始化指针指向的地址是不可用地址
    int *p;
    // *p = 4; 错误Segmentation fault: 11
//初始化方式1
    int num, *p;
    p = &num;
    *p = 4;
//初始化方式2
    int *p = (int *)malloc(4);
    *p = 4;
//多维数组做函数参数
    f(int daytab[2][13]) {}
    f(int daytab[][13]) {}
    f(int (*daytab)[13]) {} //参数是一个指针,指向具有13个整形元素的一维数组
    int *daytab[13] //[]优先级高于*,代表的是具有13个元素的数组,每个元素是一个指向int型的指针

/*指针与多维数组*/
//二维数组与指针数组的区别
    //分配了200个int类型长度的存储空间,并且通过矩阵下标计算公式20*row+col可以得到元素a[row][col]的位置
    int a[10][20];
    char name[][8] = {"Illegal", "Jan", "Feb", "Mar"};
            //存储分配:"Illegal\0Jan\0    Feb\0    Mar\0    "
    //仅仅分配了10个指针,并且没有初始化,优点在于b的每个元素指向的对象长度可以不同,这样就节省了存储,比如name
    int *b[10];
    char *name[] = {"Illegal", "Jan", "Feb", "Mar"};

/*命令行参数*/
//main函数的固定两个参数 main(int argc, char *argv[]);
//argc为参数总数,默认为1
//argc为参数内容指针数组,默认为两项,第一项为程序名,第二项为空指针

/*指向函数的指针*/
    int (*comp)(void *, void *);//comp是一个指向函数的指针,该函数具有两个void*类型的参数,返回类型为int

/*复杂声明*/
    int *f();//返回int型指针的函数
    int (*f)();//指向函数的指针,函数返回int型
    char **argv;//指针->指针->char
    int (*daytab)[13];//指针指向具有13个int型元素的数组
    int *daytab[13];//数组包含13个指向int型的指针
    void *comp();//返回void *类型的函数
    void (*comp)();//指向函数的指针,函数返回void;
    char (*(*x())[])();//指向函数的指针,函数返回指向array的指针,array包含指向func,func返回 char *
}